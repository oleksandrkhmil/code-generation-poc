// Code generated by go-swagger; DO NOT EDIT.

package form3

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountAttributes account attributes
//
// swagger:model AccountAttributes
type AccountAttributes struct {

	// Determines the qualifier code with which payments to the account are accepted. If not present, payments are accepted by default with `0000` (accepted without qualification).
	//   * `after_next_working_day` - After the next Working Day within the PSD Guidelines, FPS qualifier code `0084`.
	//   * `next_calendar_day` - On the next calendar day, FPS qualifier code `0082`.
	//   * `next_working_day` - On the next working day, FPS qualifier code `0083`.
	//   * `same_day` - On the same day, FPS qualifier code `0081`.
	//   * `some_other_time` - At an unspecified time and date within the PSD Guidelines, FPS qualifier code `0080`.
	//
	// Enum: [after_next_working_day next_calendar_day next_working_day same_day some_other_time]
	AcceptanceQualifier string `json:"acceptance_qualifier,omitempty"`

	// Classification of account, can be either `Personal` or `Business`. Only used for Confirmation of Payee.
	//   * `Business` - The account is a business account and the provided information is linked to a business.
	//   * `Personal` - The account is a personal account and the provided information is linked to an individual.
	//
	// Enum: [Personal Business]
	AccountClassification string `json:"account_classification,omitempty"`

	// 8-digit British domestic account number. Provided when creating the resource or generated by Form3. Not generated if `iban` is provided but this field is empty upon resource creation.
	//
	// Max Length: 8
	// Min Length: 8
	AccountNumber string `json:"account_number,omitempty"`

	// Alternative primary account names, up to 3 alternative account names with one name in each line of the array. Only used for Confirmation of Payee.
	//
	// Max Items: 3
	AlternativeNames []string `json:"alternative_names"`

	// Local country bank identifier, always a UK sort code for accounts usable with FPS.
	//
	// Max Length: 11
	BankID string `json:"bank_id,omitempty"`

	// Identifies the type of bank ID being used, must be `GBDSC`.
	//
	// Enum: [GBDSC]
	BankIDCode string `json:"bank_id_code,omitempty"`

	// ISO 4217 code used to identify the base currency of the account. Always `GBP` for accounts usable with FPS.
	//
	// Enum: [GBP]
	BaseCurrency string `json:"base_currency,omitempty"`

	// SWIFT BIC in either 8 or 11 character format.
	//
	// Pattern: ^(.{8}|.{11})$
	Bic string `json:"bic,omitempty"`

	// ISO 3166-1 code used to identify the domicile of the account. Always GB for accounts usable with FPS.
	//
	// Enum: [GB]
	Country string `json:"country,omitempty"`

	// A free-format reference that can be used to link this account to an external system.
	//
	CustomerID string `json:"customer_id,omitempty"`

	// IBAN of the account. Either provided when creating the resource or generated by Form3 for accounts usable with FPS.
	//
	Iban string `json:"iban,omitempty"`

	// Flag to indicate if the account is a joint account, set to `true` is this is a joint account. Only used for Confirmation of Payee.
	//
	JointAccount bool `json:"joint_account,omitempty"`

	// Name of the account holder, up to four lines possible.
	// For Confirmation of Payee, the following rules apply:
	//   * Must be the primary account name.
	//   * For concatenated personal names, joint account names and organisation names, use the first line.
	//   * If first and last names of a personal name are separated, use the first line for first names, the second line for last names.
	//   * Titles are ignored and should not be entered.
	//
	// Max Items: 4
	Name []string `json:"name"`

	// Describes the status of the account for name matching via Confirmation of Payee. The value determines the code with which Form3 responds to matched Confirmation of Payee requests to this account.
	//   * `not_supported` - Name matching via Confirmation of Payee is not supported for this account.
	//   * `opted_out` - This account has been opted out of name matching via Confirmation of Payee.
	//   * `supported` - Name matching via Confirmation of Payee is supported for this account. This is the default value if the field is not provided during account creation.
	//   * `switched` - This account has been switched to another organisation using CASS.
	//
	// Enum: [not_supported opted_out supported switched]
	NameMatchingStatus string `json:"name_matching_status,omitempty"`

	// Mask to use when validating the `reference` field of inbound payments to the account. Payments without matching reference fields will be rejected.
	// Matching rules:
	//   * `?` matches any character.
	//   * `#` matches any numeric characters (0-9).
	//   * `$` matches any alphanumeric character (a-z, A-Z).
	//   * All other characters are literals. \ can be used to escape control characters to literals.
	//   * Maximum length 35 characters.
	//   * `-` and space characters are ignored in the reference when matching.
	//
	ReferenceMask string `json:"reference_mask,omitempty"`

	// Additional information to identify the account and account holder, can be any type of additional identification, e.g. a building society roll number. Only used for Confirmation of Payee.
	//
	// Max Length: 140
	SecondaryIdentification string `json:"secondary_identification,omitempty"`

	// Status of the account. `pending` and `confirmed` are set by Form3, `closed` can be set manually.
	//   * `closed` - The account has been closed, payments to this account will be rejected with the code defined in `status_reason`.
	//   * `confirmed` - The account is active and can be used to submit and receive payments.
	//   * `pending` - The account has been created but not active yet.
	//
	// Enum: [closed confirmed pending]
	Status string `json:"status,omitempty"`

	// Additional account status information when `status` is `closed`, not present when `status` has other values. The FPS code with which inbound payments to the account will be rejected depends on the value of this field. * `beneficiary_sensitivities` - Payment cannot be applied because of Beneficiary sensitivities e.g. possible bankruptcy, FPS code 1169. Payment Admission field status_reason will be account_closed_beneficiary_sensitivities. * `business_reasons` - For business reasons only, FPS code 1100. Payment Admission field status_reason will be account_closed_business_reasons. * `closed` - Beneficiary Account closed, FPS code 1160. Payment Admission field status_reason will be account_closed. * `currency` - Account is not in currency quoted, FPS code 1165. Payment Admission field status_reason will be account_closed_currency. * `deceased` - Beneficiary deceased, FPS code 1167. Payment Admission field status_reason will be account_closed_beneficiary_deceased. * `stopped` - Beneficiary Account stopped, FPS code 1161. Payment Admission field status_reason will be account_closed_stopped. * `terms_and_conditions` - Terms and Conditions of Account do not permit crediting of these funds, FPS code 1170. Payment Admission field status_reason will be account_closed_terms_and_conditions. * `transferred` - Account transferred, FPS code 1166. Payment Admission field status_reason will be account_closed_transferred.
	//
	// Enum: [beneficiary_sensitivities business_reasons closed currency deceased stopped terms_and_conditions transferred]
	StatusReason string `json:"status_reason,omitempty"`

	// Stores alternate account details to use if the beneficiary account has been switched and payments should be forwarded to the new account.
	//
	SwitchedAccountDetails interface{} `json:"switched_account_details,omitempty"`

	// All-purpose list of key-value pairs to store data related to the account. Maximum array length is 5 entries.
	// If provided, this array will be copied into each Payment Admission resource relationship where this account is the beneficiary.
	//
	UserDefinedData interface{} `json:"user_defined_data,omitempty"`

	// Determines if modcheck validations are carried out on inbound payments to the account.
	//   * `card` - The account is a collection account for card payments and inbound payments need to have a valid card number in their reference field. Validity is checked by performing a modcheck on the reference field value.
	//   * `mandatory_reference` - Verify that a reference is provided in the reference field of the Payment resource of the inbound payment.
	//
	// Enum: [card mandatory_reference]
	ValidationType string `json:"validation_type,omitempty"`
}

// Validate validates this account attributes
func (m *AccountAttributes) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAcceptanceQualifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountClassification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlternativeNames(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankIDCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameMatchingStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var accountAttributesTypeAcceptanceQualifierPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["after_next_working_day","next_calendar_day","next_working_day","same_day","some_other_time"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeAcceptanceQualifierPropEnum = append(accountAttributesTypeAcceptanceQualifierPropEnum, v)
	}
}

const (

	// AccountAttributesAcceptanceQualifierAfterNextWorkingDay captures enum value "after_next_working_day"
	AccountAttributesAcceptanceQualifierAfterNextWorkingDay string = "after_next_working_day"

	// AccountAttributesAcceptanceQualifierNextCalendarDay captures enum value "next_calendar_day"
	AccountAttributesAcceptanceQualifierNextCalendarDay string = "next_calendar_day"

	// AccountAttributesAcceptanceQualifierNextWorkingDay captures enum value "next_working_day"
	AccountAttributesAcceptanceQualifierNextWorkingDay string = "next_working_day"

	// AccountAttributesAcceptanceQualifierSameDay captures enum value "same_day"
	AccountAttributesAcceptanceQualifierSameDay string = "same_day"

	// AccountAttributesAcceptanceQualifierSomeOtherTime captures enum value "some_other_time"
	AccountAttributesAcceptanceQualifierSomeOtherTime string = "some_other_time"
)

// prop value enum
func (m *AccountAttributes) validateAcceptanceQualifierEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeAcceptanceQualifierPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateAcceptanceQualifier(formats strfmt.Registry) error {
	if swag.IsZero(m.AcceptanceQualifier) { // not required
		return nil
	}

	// value enum
	if err := m.validateAcceptanceQualifierEnum("acceptance_qualifier", "body", m.AcceptanceQualifier); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeAccountClassificationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Personal","Business"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeAccountClassificationPropEnum = append(accountAttributesTypeAccountClassificationPropEnum, v)
	}
}

const (

	// AccountAttributesAccountClassificationPersonal captures enum value "Personal"
	AccountAttributesAccountClassificationPersonal string = "Personal"

	// AccountAttributesAccountClassificationBusiness captures enum value "Business"
	AccountAttributesAccountClassificationBusiness string = "Business"
)

// prop value enum
func (m *AccountAttributes) validateAccountClassificationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeAccountClassificationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateAccountClassification(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountClassification) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccountClassificationEnum("account_classification", "body", m.AccountClassification); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateAccountNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountNumber) { // not required
		return nil
	}

	if err := validate.MinLength("account_number", "body", m.AccountNumber, 8); err != nil {
		return err
	}

	if err := validate.MaxLength("account_number", "body", m.AccountNumber, 8); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateAlternativeNames(formats strfmt.Registry) error {
	if swag.IsZero(m.AlternativeNames) { // not required
		return nil
	}

	iAlternativeNamesSize := int64(len(m.AlternativeNames))

	if err := validate.MaxItems("alternative_names", "body", iAlternativeNamesSize, 3); err != nil {
		return err
	}

	for i := 0; i < len(m.AlternativeNames); i++ {

		if err := validate.MaxLength("alternative_names"+"."+strconv.Itoa(i), "body", m.AlternativeNames[i], 140); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributes) validateBankID(formats strfmt.Registry) error {
	if swag.IsZero(m.BankID) { // not required
		return nil
	}

	if err := validate.MaxLength("bank_id", "body", m.BankID, 11); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeBankIDCodePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GBDSC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeBankIDCodePropEnum = append(accountAttributesTypeBankIDCodePropEnum, v)
	}
}

const (

	// AccountAttributesBankIDCodeGBDSC captures enum value "GBDSC"
	AccountAttributesBankIDCodeGBDSC string = "GBDSC"
)

// prop value enum
func (m *AccountAttributes) validateBankIDCodeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeBankIDCodePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateBankIDCode(formats strfmt.Registry) error {
	if swag.IsZero(m.BankIDCode) { // not required
		return nil
	}

	// value enum
	if err := m.validateBankIDCodeEnum("bank_id_code", "body", m.BankIDCode); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeBaseCurrencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GBP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeBaseCurrencyPropEnum = append(accountAttributesTypeBaseCurrencyPropEnum, v)
	}
}

const (

	// AccountAttributesBaseCurrencyGBP captures enum value "GBP"
	AccountAttributesBaseCurrencyGBP string = "GBP"
)

// prop value enum
func (m *AccountAttributes) validateBaseCurrencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeBaseCurrencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateBaseCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.BaseCurrency) { // not required
		return nil
	}

	// value enum
	if err := m.validateBaseCurrencyEnum("base_currency", "body", m.BaseCurrency); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateBic(formats strfmt.Registry) error {
	if swag.IsZero(m.Bic) { // not required
		return nil
	}

	if err := validate.Pattern("bic", "body", m.Bic, `^(.{8}|.{11})$`); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeCountryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeCountryPropEnum = append(accountAttributesTypeCountryPropEnum, v)
	}
}

const (

	// AccountAttributesCountryGB captures enum value "GB"
	AccountAttributesCountryGB string = "GB"
)

// prop value enum
func (m *AccountAttributes) validateCountryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeCountryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	// value enum
	if err := m.validateCountryEnum("country", "body", m.Country); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	iNameSize := int64(len(m.Name))

	if err := validate.MaxItems("name", "body", iNameSize, 4); err != nil {
		return err
	}

	for i := 0; i < len(m.Name); i++ {

		if err := validate.MaxLength("name"+"."+strconv.Itoa(i), "body", m.Name[i], 140); err != nil {
			return err
		}

	}

	return nil
}

var accountAttributesTypeNameMatchingStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_supported","opted_out","supported","switched"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeNameMatchingStatusPropEnum = append(accountAttributesTypeNameMatchingStatusPropEnum, v)
	}
}

const (

	// AccountAttributesNameMatchingStatusNotSupported captures enum value "not_supported"
	AccountAttributesNameMatchingStatusNotSupported string = "not_supported"

	// AccountAttributesNameMatchingStatusOptedOut captures enum value "opted_out"
	AccountAttributesNameMatchingStatusOptedOut string = "opted_out"

	// AccountAttributesNameMatchingStatusSupported captures enum value "supported"
	AccountAttributesNameMatchingStatusSupported string = "supported"

	// AccountAttributesNameMatchingStatusSwitched captures enum value "switched"
	AccountAttributesNameMatchingStatusSwitched string = "switched"
)

// prop value enum
func (m *AccountAttributes) validateNameMatchingStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeNameMatchingStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateNameMatchingStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.NameMatchingStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameMatchingStatusEnum("name_matching_status", "body", m.NameMatchingStatus); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := validate.MaxLength("secondary_identification", "body", m.SecondaryIdentification, 140); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["closed","confirmed","pending"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeStatusPropEnum = append(accountAttributesTypeStatusPropEnum, v)
	}
}

const (

	// AccountAttributesStatusClosed captures enum value "closed"
	AccountAttributesStatusClosed string = "closed"

	// AccountAttributesStatusConfirmed captures enum value "confirmed"
	AccountAttributesStatusConfirmed string = "confirmed"

	// AccountAttributesStatusPending captures enum value "pending"
	AccountAttributesStatusPending string = "pending"
)

// prop value enum
func (m *AccountAttributes) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeStatusReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["beneficiary_sensitivities","business_reasons","closed","currency","deceased","stopped","terms_and_conditions","transferred"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeStatusReasonPropEnum = append(accountAttributesTypeStatusReasonPropEnum, v)
	}
}

const (

	// AccountAttributesStatusReasonBeneficiarySensitivities captures enum value "beneficiary_sensitivities"
	AccountAttributesStatusReasonBeneficiarySensitivities string = "beneficiary_sensitivities"

	// AccountAttributesStatusReasonBusinessReasons captures enum value "business_reasons"
	AccountAttributesStatusReasonBusinessReasons string = "business_reasons"

	// AccountAttributesStatusReasonClosed captures enum value "closed"
	AccountAttributesStatusReasonClosed string = "closed"

	// AccountAttributesStatusReasonCurrency captures enum value "currency"
	AccountAttributesStatusReasonCurrency string = "currency"

	// AccountAttributesStatusReasonDeceased captures enum value "deceased"
	AccountAttributesStatusReasonDeceased string = "deceased"

	// AccountAttributesStatusReasonStopped captures enum value "stopped"
	AccountAttributesStatusReasonStopped string = "stopped"

	// AccountAttributesStatusReasonTermsAndConditions captures enum value "terms_and_conditions"
	AccountAttributesStatusReasonTermsAndConditions string = "terms_and_conditions"

	// AccountAttributesStatusReasonTransferred captures enum value "transferred"
	AccountAttributesStatusReasonTransferred string = "transferred"
)

// prop value enum
func (m *AccountAttributes) validateStatusReasonEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeStatusReasonPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateStatusReason(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusReason) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusReasonEnum("status_reason", "body", m.StatusReason); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeValidationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["card","mandatory_reference"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeValidationTypePropEnum = append(accountAttributesTypeValidationTypePropEnum, v)
	}
}

const (

	// AccountAttributesValidationTypeCard captures enum value "card"
	AccountAttributesValidationTypeCard string = "card"

	// AccountAttributesValidationTypeMandatoryReference captures enum value "mandatory_reference"
	AccountAttributesValidationTypeMandatoryReference string = "mandatory_reference"
)

// prop value enum
func (m *AccountAttributes) validateValidationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeValidationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateValidationType(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValidationTypeEnum("validation_type", "body", m.ValidationType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account attributes based on context it is used
func (m *AccountAttributes) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountAttributes) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountAttributes) UnmarshalBinary(b []byte) error {
	var res AccountAttributes
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
